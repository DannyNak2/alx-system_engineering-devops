Secured and Monitored Web Infrastructure (3 Servers)
Architecture Overview: 

          Internet
              |
          Firewall #1
              |
      +-------------------+
      |   Load Balancer   |  <-- SSL Termination (HTTPS)
      +-------------------+
        /        |        \
Firewall #2  Firewall #2  Firewall #2
  |             |            |
Web/App #1   Web/App #2   Web/App #3
(Monitoring) (Monitoring) (Monitoring)
              |
        [MySQL DB Server]
              |
          Firewall #3


Components
Three Web/Application Servers

Each hosts the application code and serves requests from the load balancer.

Running Nginx or Apache as a reverse proxy + application server (Gunicorn, uWSGI, etc.).

Deployed in separate availability zones for redundancy.

One Load Balancer

Distributes incoming traffic evenly between the three servers.

Has an SSL certificate for www.foobar.com so that all traffic is encrypted.

Three Firewalls

Firewall #1: Protects the load balancer from the public internet. Allows only ports 80 (HTTP, optional redirect) and 443 (HTTPS).

Firewall #2: Protects each web/application server, only allowing traffic from the load balancer on necessary ports (e.g., 80/443 internally, app port if needed).

Firewall #3: Protects the database server, only allowing traffic from the web/application servers on port 3306 (MySQL).

One MySQL Database Server

Centralized data store, only accessible from the application servers.

Configured with strict user privileges and backups.

SSL Certificate

Encrypts traffic between users and the load balancer to prevent data interception.

Enforces HTTPS redirection from HTTP.

Three Monitoring Clients

Installed on each web/application server.

For example, Sumo Logic or Datadog agents.

Collects logs (access, error) and metrics (CPU, memory, network, disk usage).

Why Each Element is Added
Firewalls: Control and restrict traffic to only what’s necessary, reducing the attack surface.

SSL Certificate: Protects user data from being intercepted (MITM attacks) and ensures data integrity.

Monitoring Clients: Allow detection of performance issues, attacks, or failures in real time.

Load Balancer: Improves scalability and availability by distributing requests.

Multiple Web Servers: Ensures high availability; if one server goes down, others continue serving traffic.

Separate DB Server: Keeps sensitive data secure and allows independent scaling of the database layer.

Why Traffic is Served Over HTTPS
Ensures confidentiality, integrity, and authenticity of the data transmitted.

Protects user credentials, payment details, and other sensitive info.

Prevents downgrade attacks and eavesdropping.

What Monitoring is Used For
Detects abnormal behavior, outages, or performance bottlenecks.

Tracks resource usage to plan scaling before problems occur.

Helps with security by detecting suspicious patterns (e.g., high failed login rates).

How the Monitoring Tool Collects Data
Agent-based collection: A small client installed on each server sends metrics/logs to the monitoring service.

Pull or push method: Agent pushes data periodically or monitoring server pulls it at intervals.

Uses secure channels (HTTPS or TLS-encrypted TCP) to transmit data.

Monitoring QPS (Queries Per Second)
Enable application-level metrics (e.g., via Nginx’s stub_status or app instrumentation).

Collect and forward this data using the monitoring client.

Set up dashboards and alerts in the monitoring tool for QPS thresholds.

Issues in This Infrastructure
Terminating SSL at the Load Balancer

After SSL is terminated, traffic between load balancer and backend servers is unencrypted.

If internal network is compromised, attackers can sniff sensitive data.

Solution: Use end-to-end encryption (HTTPS from load balancer to backend).

Only One MySQL Server for Writes

Single point of failure: If it crashes, the whole system’s write capability is gone.

Solution: Implement database replication (master-slave or multi-primary) and failover mechanisms.

All Servers Having Same Components (Monolithic Setup)

If compromised, attacker gains access to DB, app, and web server from one machine.

Scaling is harder — all components compete for the same resources.

Solution: Use separation of concerns (dedicated DB servers, dedicated app servers).